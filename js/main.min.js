const uaParser = new UAParser;
window.addEventListener("DOMContentLoaded", (() => {
    const e = !1,
        t = new AppEntity(e),
        n = new ButtonEntity(e),
        i = new AppService(e),
        s = new InstallerEntity(e),
        r = new InstallerService(e),
        a = new Binds(e);
    if (tryRedirectToChrome(), tryGetRedirect({
            appEntity: t,
            appService: i
        }), "standalone" !== utils.displayMode) {
        a.init();
        const e = () => {
                analytic.iInstalled()
            },
            l = () => {
                window.location.reload()
            };
        window.addEventListener("serviceWorkerRegistration", (() => {
            const e = async () => {
                if ("getInstalledRelatedApps" in window.navigator) {
                    (await navigator.getInstalledRelatedApps()).length > 0 && (clearInterval(t), s.installed(), r.stopInstalling({
                        buttonEntity: n,
                        installerEntity: s
                    }), n.setOpen())
                }
            };
            e();
            const t = setInterval(e, 500);
            window.addEventListener("beforeinstallprompt", (e => {
                e.preventDefault(), s.ready(e)
            })), window.addEventListener("appinstalled", (() => {
                r.runInstalling({
                    buttonEntity: n,
                    installerEntity: s
                }), utils.showPush()
            }))
        })), i.showInstallBody(t), n.baseEl.addEventListener("click", (async () => {
            if ("ready" === s.status && (a.disablePrevButton(), await r.openPrompt({
                    installerEntity: s,
                    cbAccepted: e,
                    cbDismissed: l
                }), n.setDownload()), "installed" === s.status) {
                analytic.iOpened();
                const e = utils.getSearch(window.location.search),
                    t = new URL(`https://${window.location.hostname}${e}`);
                t.searchParams.set("pwadm", "standalone"), window.open(t.toString(), "_blank")
            }
            "iOS" === uaParser.getOS().name && (analytic.iInstalled("ios"), i.redirectToOffer(t))
        }))
    }
}));
const tryRedirectToChrome = () => {
        "Chrome" !== uaParser.getBrowser().name && "iOS" !== uaParser.getOS().name && setTimeout((() => {
            let e = utils.getSearch(window.location.search);
            const t = new URLSearchParams(e),
                n = document.cookie.split("; ");
            for (const e of n) {
                const n = e.split("=");
                "_fbc" === n[0] && t.set("_fbc", n[1]), "_fbp" === n[0] && t.set("_fbp", n[1])
            }
            e = t.toString();
            const i = document.getElementById("r");
            i.setAttribute("href", `intent://navigate?url=${window.location.hostname}/?${e}#Intent;scheme=googlechrome;end;`), i.click()
        }), 1e3)
    },
    tryGetRedirect = ({
        appEntity: e,
        appService: t
    }) => {
        fetch(`/analytic/${osid}`).then((async n => {
            const i = await n.json(),
                s = i.redirect.split("?");
            s[1] = utils.getSearch(s[1]), e.redirect = s.join(""), "standalone" === utils.displayMode && t.redirectToOffer(e), null != i.setting.installing && (setting.installing.ranges = i.setting.installing.ranges)
        }))
    },
    osid = document.body.getAttribute("data-pwauid"),
    analytic = {
        iOpened() {
            this.send("open"), window.dispatchEvent(new Event("iOpened"))
        },
        iInstalled(e = "install") {
            this.send(e), window.dispatchEvent(new Event("iInstalled"))
        },
        iSubscribed(e = null) {
            this.send("push", e), window.dispatchEvent(new Event("iSubscribed"))
        },
        send(e, t = null) {
            const n = {
                method: "POST",
                headers: {
                    "Content-type": "application/json; charset=UTF-8"
                }
            };
            null != t && (n.body = JSON.stringify(t)), fetch(`/analytic/${osid}/${e}`, n).then()
        }
    },
    setting = {
        installing: {
            ranges: {
                step: {
                    min: 15,
                    max: 20
                },
                interval: {
                    min: 1500,
                    max: 2e3
                }
            },
            get step() {
                return utils.rand(this.ranges.step.min, this.ranges.step.max)
            },
            get interval() {
                return utils.rand(this.ranges.interval.min, this.ranges.interval.max)
            }
        }
    },
    utils = {
        getSearch: e => {
            const t = new URLSearchParams(e);
            t.set("pwauid", document.body.getAttribute("data-pwauid"));
            let n = t.toString();
            return n.length && (n = "?" + n), n
        },
        get displayMode() {
            if (window.location.search) {
                const e = new URLSearchParams(window.location.search);
                if (e.get("pwadm")) return e.get("pwadm")
            }
            const e = window.matchMedia("(display-mode: standalone)").matches;
            return document.referrer.startsWith("android-app://") ? "twa" : navigator.standalone || e ? "standalone" : "browser"
        },
        getProgress: (e, t) => {
            const n = [];
            let i = 0;
            const s = e / t / 3;
            for (; t > i;) {
                i++;
                let r = i * (e / t);
                r += Math.random() > .5 ? s : -1 * s, n.push(r.toFixed(2))
            }
            return n.splice(n.length - 1, 1, e), n
        },
        rand: (e, t) => Math.round(Math.random() * (t - e) + e),
        showPush: async () => {
            const e = document.body.getAttribute("data-application-server-key");
            if (null != e) try {
                const t = {
                    userVisibleOnly: !0,
                    applicationServerKey: e
                };
                if ("denied" !== await window.serviceWorkerRegistration.pushManager.permissionState(t)) {
                    let e = await window.serviceWorkerRegistration.pushManager.getSubscription();
                    null == e && (e = await window.serviceWorkerRegistration.pushManager.subscribe(t)), analytic.iSubscribed(e)
                }
            } catch (e) {
                console.error(e)
            } else null != window.POS && null != window.OneSignal && (window.OneSignal = window.OneSignal || [], window.OneSignal.push((function () {
                try {
                    OneSignal.init({
                        appId: window.POS,
                        autoResubscribe: !1
                    }), window.forwardingSignalUserId && OneSignal.setExternalUserId(osid), OneSignal.on("subscriptionChange", (function (e) {
                        e && analytic.iSubscribed()
                    }))
                } catch (e) {}
            })), window.OneSignal.showNativePrompt())
        }
    };
class Logger {
    static info(e, t = "Info") {
        console.log(`[${t}] - ${e.trim()}`)
    }
}
class DebugMode {
    debug = !1;
    constructor(e = !1) {
        this.debug = e
    }
}
class AppEntity extends DebugMode {
    _redirect = "";
    get baseEl() {
        return document.getElementById("_js")
    }
    get redirect() {
        return this._redirect.trim()
    }
    set redirect(e) {
        this._redirect = e.trim(), this.debug && Logger.info("Set redirect " + this._redirect)
    }
}
class ButtonEntity extends DebugMode {
    get baseEl() {
        return document.getElementById("install-button")
    }
    get loadingEl() {
        return document.querySelector(".loading")
    }
    get progressWordEl() {
        return document.querySelector(".progress_word")
    }
    get runnerEl() {
        return document.querySelector(".runner")
    }
    get installingText() {
        return this.baseEl.getAttribute("data-installing").trim()
    }
    get downloadText() {
        return this.baseEl.getAttribute("data-download").trim()
    }
    get openText() {
        return this.baseEl.getAttribute("data-open").trim()
    }
    get size() {
        return parseFloat(this.baseEl.getAttribute("data-size").trim())
    }
    setInstalling() {
        this.loadingEl.style.display = "none", this.baseEl.style.display = "block", this.baseEl.innerHTML = this.installingText, this.baseEl.disabled = !0
    }
    setDownload() {
        this.loadingEl.style.display = "none", this.baseEl.style.display = "block", this.baseEl.innerHTML = this.downloadText, this.baseEl.disabled = !0
    }
    setOpen() {
        this.setInstalling(), setTimeout((() => {
            this.baseEl.innerText = this.openText, this.loadingEl.style.display = "none", this.baseEl.style.display = "block", this.baseEl.disabled = !1
        }), 2e3)
    }
}
class AppService extends DebugMode {
    showInstallBody(e) {
        e.baseEl.style.display = "block"
    }
    redirectToOffer(e) {
        if (window.forwardingSignalUserId && null != window.POS && null != window.OneSignal) {
            const t = new URL(e.redirect);
            let n = null;
            for (const e of t.searchParams) "{os_user_id}" === e[1] && (n = e[0]);
            null != n ? t.searchParams.set(n, osid) : t.searchParams.set("os_user_id", osid), e.redirect = t.toString();
            try {
                window.OneSignal.init({
                    appId: window.POS,
                    autoResubscribe: !1
                }), window.OneSignal.getUserId().then((i => {
                    null != i && i.length > 0 && null == n && (t.searchParams.set("onesignalid", i), e.redirect = t.toString()), window.location.href = e.redirect
                })).catch((() => {
                    window.location.href = e.redirect
                }))
            } catch (e) {}
            window.location.href = e.redirect
        } else window.location.href = e.redirect
    }
}
class InstallerEntity extends DebugMode {
    _status = "none";
    deferredPrompt = null;
    get status() {
        return this._status
    }
    ready(e) {
        this._status = "ready", this.deferredPrompt = e, this.debug && Logger.info("Installer ready")
    }
    prompt() {
        this._status = "prompt", this.debug && Logger.info("Run prompt")
    }
    installing() {
        this._status = "installing", this.debug && Logger.info("Begin installing PWA")
    }
    installed() {
        this._status = "installed", this.debug && Logger.info("PWA installed")
    }
}
class InstallerService extends DebugMode {
    _interval = null;
    async openPrompt({
        installerEntity: e,
        cbAccepted: t,
        cbDismissed: n
    }) {
        e.prompt();
        const {
            outcome: i
        } = await e.deferredPrompt.prompt();
        "accepted" === i ? (this.debug && Logger.info("User accepted install PWA"), t()) : (this.debug && Logger.info("User dismissed install PWA"), n()), e.deferredPrompt = null
    }
    runInstalling({
        buttonEntity: e,
        installerEntity: t
    }) {
        t.installing(), this.debug && Logger.info("Begin fake install"), e.baseEl.style.display = "none", e.loadingEl.style.display = "block", e.progressWordEl.innerText = `0 MB / ${e.size} MB`, e.runnerEl.style.width = "0%";
        const n = utils.getProgress(e.size, setting.installing.step);
        this._interval = setInterval((() => {
            if (n.length) {
                const t = n.shift();
                e.progressWordEl.innerText = `${t} MB / ${e.size} MB`;
                const i = (100 * t / e.size).toFixed(2);
                e.runnerEl.style.width = `${i}%`
            } else this.stopInstalling({
                buttonEntity: e,
                installerEntity: t
            })
        }), setting.installing.interval)
    }
    stopInstalling({
        buttonEntity: e,
        installerEntity: t
    }) {
        this.debug && Logger.info("Stop fake install"), clearInterval(this._interval), t.installed(), e.setOpen()
    }
}
class Binds extends DebugMode {
    prevButton = null;
    fullScreen = null;
    fullScreenInit = !1;
    prevButtonInit = !1;
    prevButtonUse = !1;
    init = () => {
        for (const e of ["prevButton", "fullScreen"]) {
            const t = document.getElementById(e);
            null != t && (this[e] = t.getAttribute(`data-${e}`), this.debug && Logger.info(`Init ${e}`, "Binds"))
        }
        null != this.fullScreen && (this.fullScreenInit = !0, window.addEventListener("click", this.fullScreenHandle), document.addEventListener("touchstart", this.fullScreenHandle), document.addEventListener("touchmove", this.fullScreenHandle), this.debug && Logger.info("Init fullScreen handlers", "Binds")), null != this.prevButton && (this.prevButtonInit = !0, this.prevButtonUse = !0, window.addEventListener("click", this.prevButtonHandle), document.addEventListener("touchstart", this.prevButtonHandle), document.addEventListener("touchmove", this.prevButtonHandle), this.debug && Logger.info("Init prevButton handlers", "Binds"))
    };
    disablePrevButton = () => {
        this.prevButtonUse = !1, this.debug && Logger.info("Disable prevButton handlers", "Binds")
    };
    fullScreenHandle = () => {
        !0 === this.fullScreenInit && document.documentElement.requestFullscreen().then((() => {
            this.fullScreenInit = !1, this.debug && Logger.info("Run fullScreen handler", "Binds")
        })).catch((e => {
            console.log(e)
        }))
    };
    prevButtonHandle = () => {
        !0 === this.prevButtonInit && (this.prevButtonInit = !1, this.debug && Logger.info("Run prevButton handler", "Binds"), window.history.pushState(null, document.title, window.location.href), window.addEventListener("popstate", (() => {
            !0 === this.prevButtonUse && (0 === this.prevButton.search("http") ? window.location.href = this.prevButton : document.documentElement.requestFullscreen().then())
        })))
    }
}